<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <link rel="icon" href="/logo.png"><title>Redis | Alice's blog</title><meta name="description" content="Just playing around"><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="VuePress 2.0.0-beta.22">
    <link rel="preload" href="/assets/js/runtime~app.882c76eb.js" as="script"><link rel="preload" href="/assets/css/styles.d0a18433.css" as="style"><link rel="preload" href="/assets/js/296.4cd9d961.js" as="script"><link rel="preload" href="/assets/js/app.9ed4fb6d.js" as="script">
    <link rel="stylesheet" href="/assets/css/styles.d0a18433.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><header class="navbar"><div class="toggle-sidebar-button"><svg class="icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><span><a href="/" class=""><img class="logo" src="/logo.png" alt="Alice&#39;s blog"><span class="site-name can-hide">Alice&#39;s blog</span></a></span><div class="navbar-links-wrapper" style=""><!--[--><!--]--><nav class="navbar-links can-hide"><!--[--><div class="navbar-links-item"><a href="/" class="nav-link" aria-label="Home"><!--[--><!--]--> Home <!--[--><!--]--></a></div><div class="navbar-links-item"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="Node"><span class="title">Node</span><span class="arrow down"></span></button><button class="mobile-dropdown-title" type="button" aria-label="Node"><span class="title">Node</span><span class="right arrow"></span></button><ul style="display:none;" class="nav-dropdown"><!--[--><li class="dropdown-item"><a href="/guide/PHP.html" class="nav-link" aria-label="PHP"><!--[--><!--]--> PHP <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/guide/MySQL.html" class="nav-link" aria-label="MySQL"><!--[--><!--]--> MySQL <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/guide/System.html" class="nav-link" aria-label="System"><!--[--><!--]--> System <!--[--><!--]--></a></li><li class="dropdown-item"><a aria-current="page" href="/guide/Redis.html" class="router-link-active router-link-exact-active nav-link router-link-active" aria-label="Redis"><!--[--><!--]--> Redis <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/guide/Web.html" class="nav-link" aria-label="Web"><!--[--><!--]--> Web <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/guide/Git.html" class="nav-link" aria-label="Git"><!--[--><!--]--> Git <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/guide/Question.html" class="nav-link" aria-label="知世"><!--[--><!--]--> 知世 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-links-item"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="Project"><span class="title">Project</span><span class="arrow down"></span></button><button class="mobile-dropdown-title" type="button" aria-label="Project"><span class="title">Project</span><span class="right arrow"></span></button><ul style="display:none;" class="nav-dropdown"><!--[--><li class="dropdown-item"><a href="/project/lin-cms-laravel.md" class="nav-link" aria-label="lin-cms-laravel"><!--[--><!--]--> lin-cms-laravel <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-links-item"><a class="nav-link external" href="https://gitee.com/aliceyd/aliceyd" rel="noopener noreferrer" target="_blank" aria-label="Gitee"><!--[--><!--]--> Gitee <span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><form class="search-box" role="search"><input type="search" autocomplete="off" spellcheck="false" value><!----></form></div></header><div class="sidebar-mask"></div><aside class="sidebar"><nav class="navbar-links"><!--[--><div class="navbar-links-item"><a href="/" class="nav-link" aria-label="Home"><!--[--><!--]--> Home <!--[--><!--]--></a></div><div class="navbar-links-item"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="Node"><span class="title">Node</span><span class="arrow down"></span></button><button class="mobile-dropdown-title" type="button" aria-label="Node"><span class="title">Node</span><span class="right arrow"></span></button><ul style="display:none;" class="nav-dropdown"><!--[--><li class="dropdown-item"><a href="/guide/PHP.html" class="nav-link" aria-label="PHP"><!--[--><!--]--> PHP <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/guide/MySQL.html" class="nav-link" aria-label="MySQL"><!--[--><!--]--> MySQL <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/guide/System.html" class="nav-link" aria-label="System"><!--[--><!--]--> System <!--[--><!--]--></a></li><li class="dropdown-item"><a aria-current="page" href="/guide/Redis.html" class="router-link-active router-link-exact-active nav-link router-link-active" aria-label="Redis"><!--[--><!--]--> Redis <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/guide/Web.html" class="nav-link" aria-label="Web"><!--[--><!--]--> Web <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/guide/Git.html" class="nav-link" aria-label="Git"><!--[--><!--]--> Git <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/guide/Question.html" class="nav-link" aria-label="知世"><!--[--><!--]--> 知世 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-links-item"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="Project"><span class="title">Project</span><span class="arrow down"></span></button><button class="mobile-dropdown-title" type="button" aria-label="Project"><span class="title">Project</span><span class="right arrow"></span></button><ul style="display:none;" class="nav-dropdown"><!--[--><li class="dropdown-item"><a href="/project/lin-cms-laravel.md" class="nav-link" aria-label="lin-cms-laravel"><!--[--><!--]--> lin-cms-laravel <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-links-item"><a class="nav-link external" href="https://gitee.com/aliceyd/aliceyd" rel="noopener noreferrer" target="_blank" aria-label="Gitee"><!--[--><!--]--> Gitee <span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-links"><!--[--><!--[--><p class="sidebar-heading sidebar-item">Redis</p><ul class=""><li><!--[--><a aria-current="page" href="/guide/Redis.html#redis-的使用规范" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="Redis 的使用规范"><!--[--><!--]--> Redis 的使用规范 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/guide/Redis.html#redis-有坑的那些命令" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="Redis 有坑的那些命令"><!--[--><!--]--> Redis 有坑的那些命令 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/guide/Redis.html#项目实战避坑操作" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="项目实战避坑操作"><!--[--><!--]--> 项目实战避坑操作 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/guide/Redis.html#redis-配置运维" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="Redis 配置运维"><!--[--><!--]--> Redis 配置运维 <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--><!--]--></ul><!--[--><!--]--></aside><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="redis" tabindex="-1"><a class="header-anchor" href="#redis" aria-hidden="true">#</a> Redis</h1><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>书《Redis 开发与运维》

Redis 千万不要乱用KEYS命令，不然会挨打的:
https://www.cnblogs.com/tonyY/p/12175032.html

阿里云Redis开发规范:
https://developer.aliyun.com/article/531067

Redis的缓存穿透及解决方法——布隆过滤器BloomFilter:
https://blog.csdn.net/wx1528159409/article/details/88357728

Redis 缓存性能实践及总结:
https://www.shangmayuan.com/a/d2f178b548a64c25854a9750.html
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h2 id="redis-的使用规范" tabindex="-1"><a class="header-anchor" href="#redis-的使用规范" aria-hidden="true">#</a> Redis 的使用规范</h2><blockquote><p>key 的规范要点</p></blockquote><p>我们设计 Redis 的 key 的时候，要注意以下这几个点：</p><ul><li>以业务名为 key 前缀，用冒号隔开，以防止 key 冲突覆盖。如，live:rank:1</li><li>确保 key 的语义清晰的情况下，key 的长度尽量小于 30 个字符。</li><li>key 禁止包含特殊字符，如空格、换行、单双引号以及其他转义字符。</li><li>Redis 的 key 尽量设置 ttl，以保证不使用的 Key 能被及时清理或淘汰。</li></ul><blockquote><p>value 的规范要点</p></blockquote><p>Redis 的 value 值不可以随意设置</p><p><strong>「第一点」</strong>，如果大量存储 bigKey 是会有问题的，会导致慢查询，内存增长过快等等。</p><ul><li>如果是 String 类型，单个 value 大小控制 10k 以内。</li><li>如果是 hash、list、set、zset 类型，元素个数一般不超过 5000。</li></ul><p><strong>「第二点」</strong>，要选择适合的数据类型。不少小伙伴只用 Redis 的 String 类型，上来就是 set 和 get。实际上，Redis 提供了「丰富的数据结构类型」，有些业务场景，更适合 <code>hash、zset</code> 等其他数据结果。</p><ul><li>Redis 的 5 中数据结构：字符串 String 哈希 Hash 列表 List 集合 Set 有序集合 Sorted Set</li></ul><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token comment">#反例</span>
<span class="token builtin class-name">set</span> user:666:name jay
<span class="token builtin class-name">set</span> user:666:age <span class="token number">18</span>

<span class="token comment">#正例</span>
hmset user:666 name jay age <span class="token number">18</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><blockquote><p>给 Key 设置过期时间，同时注意不同业务的 key，尽量过期时间分散一点</p></blockquote><ul><li>因为 Redis 的数据是存在内存中的，而内存资源是很宝贵的。</li><li>我们一般是把 Redis 当做缓存来用，而「不是数据库」，所以 key 的生命周期就不宜太长久啦。</li><li>因此，你的 key，一般建议用 <strong>「expire 设置过期时间」</strong>。</li><li>如果大量的 key 在某个时间点集中过期，到过期的那个时间点，Redis 可能会存在卡顿，甚至出现 <strong>「缓存雪崩」</strong> 现象，因此一般不同业务的 key，过期时间应该分散一些。有时候，同业务的，也可以在时间上加一个随机值，让过期时间分散一些。</li></ul><blockquote><p>建议使用批量操作提高效率</p></blockquote><p>我们日常写 SQL 的时候，都知道，批量操作效率会更高，一次更新 50 条，比循环 50 次，每次更新一条效率更高。其实 Redis 操作命令也是这个道理。</p><p>Redis 客户端执行一次命令可分为 4 个过程：1.发送命令-&gt; 2.命令排队-&gt; 3.命令执行-&gt; 4. 返回结果。1 和 4 称为 RRT（命令执行往返时间）。Redis 提供了「批量操作命令，如 mget、mset」等，可有效节约 RRT。但是呢，大部分的命令，是不支持批量操作的，比如 hgetall，并没有 mhgetall 存在。「Pipeline」 则可以解决这个问题。</p><p><code>❝Pipeline是什么呢?它能将一组Redis命令进行组装，通过一次RTT传输给Redis，再将这组Redis命令的执行结果按顺序返回给客户端.❞</code></p><p>没有使用 Pipeline 时发送 n 条命令，计算了 n 次；使用 Pipeline 执行了 n 次命令，整个过程只需要 1 次 RTT</p><h2 id="redis-有坑的那些命令" tabindex="-1"><a class="header-anchor" href="#redis-有坑的那些命令" aria-hidden="true">#</a> Redis 有坑的那些命令</h2><blockquote><p>慎用 O(n)复杂度命令，如 hgetall、smember，lrange 等</p></blockquote><p>因为 Redis 是单线程执行命令的。hgetall、smember 等命令时间复杂度为 O(n)，当 n 持续增加时，会导致 Redis CPU 持续飙高，阻塞其他命令的执行。</p><p><code>❝hgetall、smember，lrange等这些命令不是一定不能使用，需要综合评估数据量，明确n的值，再去决定。比如hgetall，如果哈希元素n比较多的话，可以优先考虑使用「hscan」。❞</code></p><blockquote><p>慎用 Redis 的 monitor 命令</p></blockquote><p>Redis Monitor 命令用于实时打印出 Redis 服务器接收到的命令，如果我们想知道客户端对 redis 服务端做了哪些命令操作，就可以用 Monitor 命令查看，但是它一般「调试」用而已，尽量不要在生产上用！因为「monitor 命令可能导致 redis 的内存持续飙升。」</p><p><code>❝monitor的模型是酱紫的，它会将所有在Redis服务器执行的命令进行输出，一般来讲Redis服务器的QPS是很高的，也就是如果执行了monitor命令，Redis服务器在Monitor这个客户端的输出缓冲区又会有大量“存货”，也就占用了大量Redis内存。❞</code></p><blockquote><p>生产环境不能使用 keys 指令</p></blockquote><p>Redis Keys 命令用于查找所有符合给定模式 pattern 的 key。如果想查看 Redis 某类型的 key 有多少个，不少小伙伴想到用 keys 命令，如下：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>keys key前缀*
</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>但是，redis 的<code>keys</code>是遍历匹配的，复杂度是<code>O（n）</code>，数据库数据越多就越慢。我们知道，redis 是单线程的，如果数据比较多的话，keys 指令就会导致 redis 线程阻塞，线上服务也会停顿了，直到指令执行完，服务才会恢复。因此，<strong>「一般在生产环境，不要使用 keys 指令」</strong>。官方文档也有声明：</p><p><code>❝Warning: consider KEYS as a command that should only be used in production environments with extreme care. It may ruin performance when it is executed against large databases. This command is intended for debugging and special operations, such as changing your keyspace layout. Don&#39;t use KEYS in your regular application code. If you&#39;re looking for a way to find keys in a subset of your keyspace, consider using sets.❞</code></p><p>其实，可以使用 scan 指令，它同 keys 命令一样提供模式匹配功能。它的复杂度也是 O(n)，但是它通过游标分步进行，<strong>「不会阻塞 redis 线程」</strong>;但是会有一定的 <strong>「重复概率」</strong>，需要在 <strong>「客户端做一次去重」</strong>。</p><p><code>❝scan支持增量式迭代命令，增量式迭代命令也是有缺点的：举个例子， 使用 SMEMBERS 命令可以返回集合键当前包含的所有元素， 但是对于 SCAN 这类增量式迭代命令来说， 因为在对键进行增量式迭代的过程中， 键可能会被修改， 所以增量式迭代命令只能对被返回的元素提供有限的保证 。❞</code></p><blockquote><p>禁止使用 flushall、flushdb</p></blockquote><ul><li>Flushall 命令用于清空整个 Redis 服务器的数据(删除所有数据库的所有 key )。</li><li>Flushdb 命令用于清空当前数据库中的所有 key。</li></ul><p>这两命令是原子性的，不会终止执行。一旦开始执行，不会执行失败的。</p><blockquote><p>注意使用 del 命令</p></blockquote><p>删除 key 你一般使用什么命令？是直接 del？如果删除一个 key，直接使用 del 命令当然没问题。但是，你想过 del 的时间复杂度是多少嘛？我们分情况探讨一下：</p><ul><li>如果删除一个 String 类型的 key，时间复杂度就是<code>O（1）</code>，<strong>「可以直接 del」</strong>。</li><li>如果删除一个 List/Hash/Set/ZSet 类型时，它的复杂度是<code>O(n)</code>, n 表示元素个数。</li></ul><p>因此，如果你删除一个 List/Hash/Set/ZSet 类型的 key 时，元素越多，就越慢。<strong>「当 n 很大时，要尤其注意」</strong>，会阻塞主线程的。那么，如果不用 del，我们应该怎么删除呢？</p><ul><li>如果是 List 类型，你可以执行<code>lpop或者rpop</code>，直到所有元素删除完成。</li><li>如果是 Hash/Set/ZSet 类型，你可以先执行<code>hscan/sscan/scan</code>查询，再执行 hdel/srem/zrem 依次删除每个元素。</li></ul><blockquote><p>避免使用 SORT、SINTER 等复杂度过高的命令</p></blockquote><p>执行复杂度较高的命令，会消耗更多的 CPU 资源，会阻塞主线程。所以你要避免执行如<code>SORT、SINTER、SINTERSTORE、ZUNIONSTORE、ZINTERSTORE</code>等聚合命令，一般建议把它放到客户端来执行</p><h2 id="项目实战避坑操作" tabindex="-1"><a class="header-anchor" href="#项目实战避坑操作" aria-hidden="true">#</a> 项目实战避坑操作</h2><blockquote><p>分布式锁使用的注意点</p></blockquote><p>分布式锁其实就是，控制分布式系统不同进程共同访问共享资源的一种锁的实现。秒杀下单、抢红包等等业务场景，都需要用到分布式锁。我们经常使用 Redis 作为分布式锁，主要有这些注意点：</p><ol><li>两个命令 SETNX + EXPIRE 分开写（典型错误实现范例）</li></ol><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">if</span>（jedis<span class="token punctuation">.</span><span class="token function">setnx</span><span class="token punctuation">(</span>key_resource_id<span class="token punctuation">,</span>lock_value<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span>）<span class="token punctuation">{</span> <span class="token comment">//加锁</span>
    expire（key_resource_id，<span class="token number">100</span>）<span class="token punctuation">;</span> <span class="token comment">//设置过期时间</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">do</span> something  <span class="token comment">//业务请求</span>
    <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">finally</span> <span class="token punctuation">{</span>
       jedis<span class="token punctuation">.</span><span class="token function">del</span><span class="token punctuation">(</span>key_resource_id<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//释放锁</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>如果执行完<code>setnx</code>加锁，正要执行 expire 设置过期时间时，进程 crash 或者要重启维护了，那么这个锁就“长生不老”了，<code>「别的线程永远获取不到锁」</code>啦，所以一般分布式锁不能这么实现。</p><ol start="2"><li>SETNX + value 值是过期时间 (有些小伙伴是这么实现，有坑)</li></ol><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">long</span> expires <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> expireTime<span class="token punctuation">;</span> <span class="token comment">//系统时间+设置的过期时间</span>
<span class="token class-name">String</span> expiresStr <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>expires<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 如果当前锁不存在，返回加锁成功</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>jedis<span class="token punctuation">.</span><span class="token function">setnx</span><span class="token punctuation">(</span>key_resource_id<span class="token punctuation">,</span> expiresStr<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 如果锁已经存在，获取锁的过期时间</span>
<span class="token class-name">String</span> currentValueStr <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key_resource_id<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 如果获取到的过期时间，小于系统当前时间，表示已经过期</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>currentValueStr <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token class-name">Long</span><span class="token punctuation">.</span><span class="token function">parseLong</span><span class="token punctuation">(</span>currentValueStr<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

     <span class="token comment">// 锁已过期，获取上一个锁的过期时间，并设置现在锁的过期时间（不了解redis的getSet命令的小伙伴，可以去官网看下哈）</span>
    <span class="token class-name">String</span> oldValueStr <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">getSet</span><span class="token punctuation">(</span>key_resource_id<span class="token punctuation">,</span> expiresStr<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldValueStr <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> oldValueStr<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>currentValueStr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token comment">// 考虑多线程并发的情况，只有一个线程的设置值和当前值相同，它才可以加锁</span>
         <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">//其他情况，均返回加锁失败</span>
<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p>这种方案的 <strong>「缺点」</strong>：</p><ul><li>过期时间是客户端自己生成的，分布式环境下，每个客户端的时间必须同步。</li><li>没有保存持有者的唯一标识，可能被别的客户端释放/解锁。</li><li>锁过期的时候，并发多个客户端同时请求过来，都执行了 jedis.getSet()，最终只能有一个客户端加锁成功，但是该客户端锁的过期时间，可能被别的客户端覆盖。</li></ul><ol start="3"><li>：SET 的扩展命令（SET EX PX NX）（注意可能存在的问题）</li></ol><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">if</span>（jedis<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key_resource_id<span class="token punctuation">,</span> lock_value<span class="token punctuation">,</span> <span class="token string">&quot;NX&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;EX&quot;</span><span class="token punctuation">,</span> <span class="token number">100</span>s<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span>）<span class="token punctuation">{</span> <span class="token comment">//加锁</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">do</span> something  <span class="token comment">//业务处理</span>
    <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">finally</span> <span class="token punctuation">{</span>
       jedis<span class="token punctuation">.</span><span class="token function">del</span><span class="token punctuation">(</span>key_resource_id<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//释放锁</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><strong>这个方案还是可能存在问题：</strong></p><ul><li>锁过期释放了，业务还没执行完。</li><li>锁被别的线程误删。</li></ul><ol start="4"><li>SET EX PX NX + 校验唯一随机值,再删除（解决了误删问题，还是存在锁过期，业务没执行完的问题）</li></ol><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">if</span>（jedis<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key_resource_id<span class="token punctuation">,</span> uni_request_id<span class="token punctuation">,</span> <span class="token string">&quot;NX&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;EX&quot;</span><span class="token punctuation">,</span> <span class="token number">100</span>s<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span>）<span class="token punctuation">{</span> <span class="token comment">//加锁</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">do</span> something  <span class="token comment">//业务处理</span>
    <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">finally</span> <span class="token punctuation">{</span>
       <span class="token comment">//判断是不是当前线程加的锁,是才释放</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>uni_request_id<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>jedis<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key_resource_id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        jedis<span class="token punctuation">.</span><span class="token function">del</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//释放锁</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>在这里，判断是不是当前线程加的锁和释放锁不是一个原子操作。如果调用 jedis.del()释放锁的时候，可能这把锁已经不属于当前客户端，会解除他人加的锁。</p><p>一般也是用 lua 脚本代替。lua 脚本如下：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">if</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">&#39;get&#39;</span><span class="token punctuation">,</span>KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> ARGV<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> then
   <span class="token keyword">return</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">&#39;del&#39;</span><span class="token punctuation">,</span>KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">else</span>
   <span class="token keyword">return</span> <span class="token number">0</span>
end<span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ol start="5"><li>Redisson 框架 + Redlock 算法 解决锁过期释放，业务没执行完问题+单机问题</li></ol><p>Redisson 使用了一个 Watch dog 解决了锁过期释放，业务没执行完问题，Redisson 原理图如下:</p><p>线程一 ——&gt; 删除锁 ——&gt; 用哈希算法选择节点 ——&gt;（执行 lua 脚本）——&gt; Redis 集群 master ——&gt; Redis 集群 slave Redis 集群 master ——&gt; （发布订阅）线程二/线程一 ——&gt; 获取锁 ——&gt; 加锁成功 ——&gt; 看门狗 Watch dog（每隔十秒查看是否持有锁，延长生存时间） ——&gt; Redis 集群 master</p><p><code>❝如果线程一在Redis的master节点上拿到了锁，但是加锁的key还没同步到slave节点。恰好这时，master节点发生故障，一个slave节点就会升级为master节点。线程二就可以获取同个key的锁啦，但线程一也已经拿到锁了，锁的安全性就没了。❞</code></p><blockquote><p>缓存一致性注意点</p></blockquote><ul><li>如果是读请求，先读缓存，后读数据库</li><li>如果写请求，先更新数据库，再写缓存</li><li>每次更新数据后，需要清除缓存</li><li>缓存一般都需要设置一定的过期失效</li><li>一致性要求高的话，可以使用 biglog+MQ 保证。</li></ul><blockquote><p>合理评估 Redis 容量，避免由于频繁 set 覆盖，导致之前设置的过期时间无效。</p></blockquote><p>我们知道，Redis 的所有数据结构类型，都是可以设置过期时间的。假设一个字符串，已经设置了过期时间，你再去重新设置它，就会导致之前的过期时间无效。</p><p>Redis setKey 源码如下：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">void</span> <span class="token function">setKey</span><span class="token punctuation">(</span>redisDb <span class="token operator">*</span>db<span class="token punctuation">,</span>robj <span class="token operator">*</span>key<span class="token punctuation">,</span>robj <span class="token operator">*</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">lookupKeyWrite</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token operator">==</span>NULL<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token function">dbAdd</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span>key<span class="token punctuation">,</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
    <span class="token function">dbOverwrite</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span>key<span class="token punctuation">,</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">incrRefCount</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">removeExpire</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//去掉过期时间</span>
    <span class="token function">signalModifiedKey</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>实际业务开发中，同时我们要合理评估 Redis 的容量，避免频繁 set 覆盖，导致设置了过期时间的 key 失效。新手小白容易犯这个错误</p><blockquote><p>缓存穿透问题</p></blockquote><p>先来看一个常见的缓存使用方式：读请求来了，先查下缓存，缓存有值命中，就直接返回；缓存没命中，就去查数据库，然后把数据库的值更新到缓存，再返回。</p><div class="language-flow ext-flow line-numbers-mode"><pre class="language-flow"><code>st<span class="token operator">=&gt;</span>start<span class="token operator">:</span>  读请求
cond<span class="token operator">=&gt;</span>condition<span class="token operator">:</span> 是否命中缓存
sub1<span class="token operator">=&gt;</span>subroutine<span class="token operator">:</span> 从数据库读取数据
io<span class="token operator">=&gt;</span>subroutine<span class="token operator">:</span> 更新缓存
e<span class="token operator">=&gt;</span>end<span class="token operator">:</span> 返回数据
st<span class="token operator">-</span><span class="token operator">&gt;</span>cond
<span class="token function">cond</span><span class="token punctuation">(</span><span class="token constant">Y</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span>e
<span class="token function">cond</span><span class="token punctuation">(</span><span class="token constant">N</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span>sub1<span class="token operator">-</span><span class="token operator">&gt;</span>io<span class="token operator">-</span><span class="token operator">&gt;</span>e
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><strong>「缓存穿透」</strong>：指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，进而给数据库带来压力。</p><p>缓存穿透一般都是这几种情况产生的：</p><ul><li><strong>「业务不合理的设计」</strong>，比如大多数用户都没开守护，但是你的每个请求都去缓存，查询某个 userid 查询有没有守护。</li><li><strong>「业务/运维/开发失误的操作」</strong>，比如缓存和数据库的数据都被误删除了。</li><li><strong>「黑客非法请求攻击」</strong>，比如黑客故意捏造大量非法请求，以读取不存在的业务数据。</li></ul><p><strong>「如何避免缓存穿透呢？」</strong> 一般有三种方法。</p><ol><li><p>如果是非法请求，我们在 API 入口，对参数进行校验，过滤非法值。</p></li><li><p>如果查询数据库为空，我们可以给缓存设置个空值，或者默认值。但是如有有写请求进来的话，需要更新缓存哈，以保证缓存一致性，同时，最后给缓存设置适当的过期时间。（业务上比较常用，简单有效）</p></li><li><p>使用布隆过滤器快速判断数据是否存在。即一个查询请求过来时，先通过布隆过滤器判断值是否存在，存在才继续往下查。</p></li></ol><p><strong>❝ 布隆过滤器原理：它由初始值为 0 的位图数组和 N 个哈希函数组成。一个对一个 key 进行 N 个 hash 算法获取 N 个值，在比特数组中将这 N 个值散列后设定为 1，然后查的时候如果特定的这几个位置都为 1，那么布隆过滤器判断该 key 存在。❞</strong></p><blockquote><p>缓存雪奔问题</p></blockquote><p><strong>「缓存雪奔：」</strong> 指缓存中数据大批量到过期时间，而查询数据量巨大，请求都直接访问数据库，引起数据库压力过大甚至 down 机。</p><ul><li>缓存雪奔一般是由于大量数据同时过期造成的，对于这个原因，可通过均匀设置过期时间解决，即让过期时间相对离散一点。如采用一个较大固定值+一个较小的随机值，5 小时+0 到 1800 秒酱紫。</li><li>Redis 故障宕机也可能引起缓存雪奔。这就需要构造 Redis 高可用集群啦。</li></ul><blockquote><p>缓存击穿问题</p></blockquote><p><strong>「缓存击穿：」</strong> 指热点 key 在某个时间点过期的时候，而恰好在这个时间点对这个 Key 有大量的并发请求过来，从而大量的请求打到 db。</p><p>缓存击穿看着有点像，其实它两区别是，缓存雪奔是指数据库压力过大甚至 down 机，缓存击穿只是大量并发请求到了 DB 数据库层面。可以认为击穿是缓存雪奔的一个子集吧。有些文章认为它俩区别，是区别在于击穿针对某一热点 key 缓存，雪奔则是很多 key。</p><p>解决方案就有两种：</p><ul><li><strong>「1.使用互斥锁方案」</strong>。缓存失效时，不是立即去加载 db 数据，而是先使用某些带成功返回的原子操作命令，如(Redis 的 setnx）去操作，成功的时候，再去加载 db 数据库数据和设置缓存。否则就去重试获取缓存。</li><li><strong>「2. “永不过期”」</strong>，是指没有设置过期时间，但是热点数据快要过期时，异步线程去更新和设置过期时间。</li></ul><blockquote><p>缓存热 key 问题</p></blockquote><p>在 Redis 中，我们把访问频率高的 key，称为热点 key。如果某一热点 key 的请求到服务器主机时，由于请求量特别大，可能会导致主机资源不足，甚至宕机，从而影响正常的服务。</p><p>而热点 Key 是怎么产生的呢？主要原因有两个</p><ul><li>用户消费的数据远大于生产的数据，如秒杀、热点新闻等读多写少的场景。</li><li>请求分片集中，超过单 Redi 服务器的性能，比如固定名称 key，Hash 落入同一台服务器，瞬间访问量极大，超过机器瓶颈，产生热点 Key 问题。</li></ul><p>那么在日常开发中，如何识别到热点 key 呢？</p><ul><li>凭经验判断哪些是热 Key；</li><li>客户端统计上报；</li><li>服务代理层上报</li></ul><p>如何解决热 key 问题？</p><ul><li>Redis 集群扩容：增加分片副本，均衡读流量；</li><li>对热 key 进行 hash 散列，比如将一个 key 备份为 key1,key2……keyN，同样的- 数据 N 个备份，N 个备份分布到不同分片，访问时可随机访问 N 个备份中的一个，- 进一步分担读流量；</li><li>使用二级缓存，即 JVM 本地缓存,减少 Redis 的读请求。</li></ul><h2 id="redis-配置运维" tabindex="-1"><a class="header-anchor" href="#redis-配置运维" aria-hidden="true">#</a> Redis 配置运维</h2><blockquote><p>使用长连接而不是短连接，并且合理配置客户端的连接池</p></blockquote><ul><li>如果使用短连接，每次都需要过 TCP 三次握手、四次挥手，会增加耗时。然而长连接的话，它建立一次连接，redis 的命令就能一直使用，酱紫可以减少建立 redis 连接时间。</li><li>连接池可以实现在客户端建立多个连接并且不释放，需要使用连接的时候，不用每次都创建连接，节省了耗时。但是需要合理设置参数，长时间不操作 Redis 时，也需及时释放连接资源</li></ul><blockquote><p>只使用 db0</p></blockquote><ul><li>一个连接，Redis 执行命令 select 0 和 select 1 切换，会损耗新能。</li><li>Redis Cluster 只支持 db0，要迁移的话，成本高</li></ul><blockquote><p>设置 maxmemory + 恰当的淘汰策略。</p></blockquote><p>为了防止内存积压膨胀。比如有些时候，业务量大起来了，redis 的 key 被大量使用，内存直接不够了，运维小哥哥也忘记加大内存了。难道 redis 直接这样挂掉？所以需要根据实际业务，选好 maxmemory-policy(最大内存淘汰策略)，设置好过期时间。一共有 8 种内存淘汰策略：</p><ul><li>volatile-lru：当内存不足以容纳新写入数据时，从设置了过期时间的 key 中使用 LRU（最近最少使用）算法进行淘汰；</li><li>allkeys-lru：当内存不足以容纳新写入数据时，从所有 key 中使用 LRU（最近最少使用）算法进行淘汰。</li><li>volatile-lfu：4.0 版本新增，当内存不足以容纳新写入数据时，在过期的 key 中，使用 LFU 算法进行删除 key。</li><li>allkeys-lfu：4.0 版本新增，当内存不足以容纳新写入数据时，从所有 key 中使用 LFU 算法进行淘汰；</li><li>volatile-random：当内存不足以容纳新写入数据时，从设置了过期时间的 key 中，随机淘汰数据；。</li><li>allkeys-random：当内存不足以容纳新写入数据时，从所有 key 中随机淘汰数据。</li><li>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的 key 中，根据过期时间进行淘汰，越早过期的优先被淘汰； noeviction：默认策略，当内存不足以容纳新写入数据时，新写入操作会报错。</li></ul><blockquote><p>开启 lazy-free 机制</p></blockquote><p>Redis4.0+版本支持 lazy-free 机制，如果你的 Redis 还是有 bigKey 这种玩意存在，建议把 lazy-free 开启。当开启它后，Redis 如果删除一个 bigkey 时，释放内存的耗时操作，会放到后台线程去执行，减少对主线程的阻塞影响。</p><div class="language-mermaid ext-mermaid line-numbers-mode"><pre class="language-mermaid"><code>graph LR
A[Redis客户端]
    A --&gt;|del blg key| B(Redis服务器)
    B|开启free-lazy| --&gt;|del blg key| C(主线程)
    B --&gt;|释放内存| D(后台线程)
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><!--]--></div><footer class="page-meta"><div class="meta-item edit-link"><a class="nav-link external meta-item-label" href="https://gitee.com/aliceyd/aliceyd/edit/master/docs/guide/Redis.md" rel="noopener noreferrer" target="_blank" aria-label="Edit this page"><!--[--><!--]--> Edit this page <span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></div><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><span class="meta-item-info">2021/9/1 下午6:30:23</span></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: 862312883@qq.com">Alice</span><!----><!--]--><!--]--></span></div></footer><!----><!--[--><!--]--></main></div><!----><!--]--></div>
    <script src="/assets/js/runtime~app.882c76eb.js" defer></script><script src="/assets/js/296.4cd9d961.js" defer></script><script src="/assets/js/app.9ed4fb6d.js" defer></script>
  </body>
</html>
